Giorno 1):

Parole del vocabolario in memoria: 

Fare semplicemente una hashMap <Stringa, boolean> map ;


NOTE riguardo come sviluppare le classi per fare le diverse operazioni:
Lato server implementero diverse classi "task" che quindi implementano runnable per effettuare le diverse operazioni che il client richiede al
al server, voglio usare java NIO quindi anche un selettore .
--------------------------------------------------------------------------------------------------------------------

Giorno 2):

	1) Implemento la fase di registrazione, tramite RMI, quando il client si registra dovrà passare come paramentro dellare gistrazione lo stub per far si che possa ricevere le notifiche dal server dopo aver effettuato il login riguardo gli aggiornamenti della classifica 
	
	2) Riguardo la lista contenente gli utenti registrati, per prima cosa l accesso alla lista dovra essere fatto in mutua esclusione, questo perche possono esserci contemporaneamente thread che leggono e thread che scrivono nella lista
	Soluzione del 2) ho implementato il meccanismo per la registrazione e della terminazione di RMI
	
	3) Ora vogliio implementare l'operazione di notifica del server verso il client, per farlo il client deve passare un oggetto esportato al server senza che venga registrato sul registro, il testo dice: " In seguito alla login il client si registra a un
servizio di notifica del server per ricevere aggiornamenti sulla classifica degli utenti", quindi la mia idea è passare lo stub in fase di registrazione, e poi abilitare il servizio di notifica quando il client effettua il login e disabilitarlo quando effettua il logout.
--------------------------------------------------------------------------------------------------------------------

Giorno 3):
	Nota: ho ottimizzato la ricerca dei registrati usando una un HashSet in modo che il metodo contains abbia costo
		costante 
	1) Ora devo individuare quali sono le operazioni che devo serializzare in caso di riavvio del server,
		Quelle di cui sono sicuro sono: Gli utenti registarti.
		
		Ragionamento: Quando un utente si registra a wordle viene inserito nel hashSet, il punto è che 
			      il server potrebbe essere spento in qualsiasi momento, sia con una operazione di riavvio
			      del server diciamo "delicata" (richiesta dal gestor edel server) e che quindi è possibile
			      effettuare controlli prima di scarricare il file sul disco, sia per un eventuale chiusura
			      "brusca" per un qualche motivo, quindi bisogna fare in modo che il file json che conterrà
			      i dati venga arricchito man mano che gli utenti si registrano, quindi poer fare questo, 
			      quello che voglio fare è lanciare un thread che in "background" crea via via il file json   
	
	2) Per seguire il  ragionamento del punto 1), bisogna quindi implementare il threadpool, il mio pool di thread
	lo implemento con una capacita limitata di thread in modo tale da non sovraccaricare la macchina,
	il server sara formato di un thread che smista le connessioni, un server che si occupa di creare 
	il file json e poi una serie di worker per elaborare le richieste, Inoltre considerare anche i 
	threads che possono essere lanciati per effettuare le diverse scritture al servizio a causa dell RMI, 
	evito di scrivere sul disco direttamente quando registro i client in quanto è una operazione molto lenta 
	e siccome sono con la lock potrei rallentare troppo altri thread che vorrebbero magari solo leggere
	
	3) Siccome devo cominciare a implementare il threadpool devo avere i dati, tali dati devono essere contenuti 
	all interno di un file che il server in fase di configurazione deve leggere per poi avviarsi 
	Questo file faccio in modo che il server riesca a trovarlo automaticamnete senza che gli venga asseggnato alcun
	path e che non gli venga fornito nulla da tastiera, per farlo devo inserire nel codice sorgente
	la cartella da cui cominciare a cercare ricorsivamente, ricerca e apertura del file di configurazione 
	implementata, adesso bisogna scegliere un formasto di tale file per effettuare il parsing, per ora le info 
	che so di certo che voglio sapere sono il numero di thread del server e dopo quanto tempo il server deve 
	proporre una nuova parola, riguardo al formato da usare: 
	
	FildNome:dato
	FildNome:dato
	FildNome:dato
	.
	.
	. 		
--------------------------------------------------------------------------------------------------------------------
		
Giorno 4) :	
		
	Continuo il discorso precedente, a questo punto bisogna fare il parsing del file di config, 
	per ora le info che mi interessa recuoerare sono
	thread:10
	timeword:0 24	
	Quindi leggo il file linea per linea e estraggo i dati inserendoli in opportune variabili statiche 
	all interno della classe StartServerWordle per poi passarle ad un istanza di ServerWordle
	I primi dati sono statio raccolti, ora dopo aver implementato il pool di thread comincio con i task:
	
	1) il primo task che implemento è quello che salva lo stato del sistema su un file json, come ho gia detto 
	i dati  che deve salvare riguardano gli utenti, quindi, comincio con gli utenti registati (credo che alla fine
	sarà l'unica cosa da dover scaricare sul json ma vedremo):
		Implemento un task che verra eseguito da un thread su un ciclo infinito per scrivere il file json, 
		per fare cio quindi c'è bisogno di una condition variable per far fermare il thread quando non ci sono
		utenti che non abbia gia registarto uso "CondWriteJson"(<-- è il nome della condition variable che uso), 
		la classe che conterra il metodo run per effettuare quest aoperazione si chiama MakeJson
		Per far capire al thread che serializza quali utenti scrivere su json uso una lista di supporto che 
		conterra l'username dell utente da scrivere su json, cosi il thread fara la pop dalla lista e con tale
		username cerca nel hashset in tempo costante e scrive l'utente sul file
		
	NOTA IMPORTANTE!!! Ho dovuto cambiare l implementazione della struttura dati che contiene i registrati
			L ho dovuta rendere una HASHMAP invece che HASHSET in  quanto con hashset non potevo
			recuperare gli utenti, a questo punto non serve piu fare l override di equals e 
			hashcode in utenti perche uso in contains la chiave che è l username che deve essere univoco
			
			
	C'era un problema sulla cond della readwrite lock per l'inserimento in hashmap e scrittura sul json, 
	siccome la readlock non puo creare la var di condizione è necessario che usi la writelock per creare la
	condizione su cui si addormenta il thread che deve serializzare, ho paura ora che quando lancio la
	serializzazione mi venga sollevata un exception, devo testare, come pensavo non funziona perche la signal non
	viene fatta credo, quindi quello che mi conviene fare è usare altre lock, quindi creo un altra coppia di lock
	che verranno condivise dal thread dell rmi solo per fare la signal verso il thread che deve serializzare che 
	intanto dorme, anzi ancora meglio quello che posso fare è usare invece della linked list per contenere
	gli username degli utenti che devono essere scritti su json usare una blockingqueue direttamente, 
	appesantendo di meno il codice,
	NOTA: siccome usa lo blocking queue quando faccio la take il thread va a dormire, quello che succede è
	quindi che per risvegliare quel thread non basta chiudere il pool ma bisogna agiungere un elemento in coda
	e fare un controllo che sia un elemento nullo prima di serializzare cosi facendo poi il thread 
	testera il flag per la ricezione di una interrupted e chiudera   

					
--------------------------------------------------------------------------------------------------------------------
	
Giorno 5) : Riprendendo dal fatto che quando il server termina deve svegliare il thread che serializza devo inviare 
	    sulla blockingqueue un username fittizio per far svegliare il thread quello che succede pero è che devo 
	    scegliere un username particolare che gli utenti non possono usare per registrare devo fare questo 
	    controllo quando gli utenti tentano di registrarsi, il nome non diposnibile è STOP_THREAD.
	    Altra considerazione da fare: Il server deve scrivere sul json gli utenti che si registrano, 
	    quando si spegne rilegge dal json e carica i dati, a questo punto potrebbero iscriversi altri utenti 
	    quindi non posso riscrivere tutto il json da capo, allora come mi comporto?????  
	     
-------------------------------------------------------------------------------------------------------------------


Giorno 6) : Riguardo il fatto visto la scorsa sezione del json, la mia idea è quella di utilizzare piu file
	    per la serializzazione, uno per ogni riavvio del server, in modo da non avere problemi per la 
	    scrittura e l eventuale rilettura dei file, posso quindi poi usare l aogo che implementato per la ricerca
	    dei file in una dir specificata per recuperare i file .json e ricostruiìre le strutture dati, 
	    Ora provo a implementare l'eventuale recupero dei dati:
	    
	    	Ragionamento: Prima cosa devo inserire nel file di configurazione il campo per recuperare la dir di 
	    	dove andare a scrivere i file json e quindi poi anche a recuperarli (Seguendo sempre il formato del 
	    	file config), bisogna quindi fornire una directory che deve essere gia presente nella dir del progetto
	    	Tale dir la chiamo JsonSerializzation (ok), ora devo fare in modo che ogni volta che il server si 
	    	riavvi acrea un nuovo file .json, quindi se il file esiste gia deve crearne un altro perche sarà 
	    	un altra run, quindi il server ad ogni riavvio deve controllare del nella dir dove sono presenti 
	    	i file json esistono file json, anzi, ad ogni riavvio il server deve controllare se la dir che
	    	dovrà contenere i file json esiste per prima cosa, se non esiste la deve creare, cosi facendo,
	    	se la dir esiste non deveo cercare se contiene file json perche sicuramente ne conterrà, allora deve
	    	creare un nuovo file.
	    	Nota siccome devo creare un nuovo file .json ad ogni  riavvio, mi serve sapere che nome dargli, 
	    	il nome sara sempre uguale tranne per un numero es 12_DataStorage.json, il 12 sarà un numero 
	    	presente nel file di configurazione, al primo avvio sarà 0, dopo la lettura di tale campo il numero
	    	varra aggiornato subito. Tale campo si chiamerà versionjson.
	    	
	    	Questo ragionamento non va bene, la soluzione migliore è creare un file json unico e modificarlo ad 
	    	ogni riavvio, quello che faccio quindi è creare la dir se non è presente in modo da avere piu 
	    	disaccoppiamento dal file system, inizialmente il file json viene creato.
	    	Ora devo capire come fare a serializzare anche lo stub che ogni utente ha nella sua definizione
	    	se non risolvo questo problema non posso andare avanti, provo a non esportare il meccanismo di
	    	notifica e inviare lo stub come parametro normale, non funziona, devo capire come serializzare un 
	    	oggetto di tipo proxy
		
-------------------------------------------------------------------------------------------------------------------

Giorno 7):	Ricomincio da dal discorso della serializzazione, quello che stavo tentando di fare non si puo
		fare facilmente, il punto è che non c'è bisogno, il fatto è che le notifiche il server le invia al
		client dopo che il client ha fatto il login, a questo punto posso chiedere al client di inviare 
		lo stub che sarà usato per mandare le noptifiche, quindi quando creo un Utente, non devo inserire lo 
		stub ma lo stub deve essere inviato dal client solo quando si logga per poi effettuare la 
		serializzazione, poi, quando dovrò serializzare nuovamente devo trovare il modo di eliminare lo stub, 
		questo perche non riesco a serializzarlo. A questo punto tolgo lo stub dalla  segnatura del metodo 
		registrazione  e creo un altro metodo all'interno dell interfaccia/classe remota in modo da poter 
		passare lo stub quando viene effettuata la login. Quindi fino a questo punto, quello che succede è 
		che riesco a serializzare e recuperare lo stato del sistema, per quanto riguarda lo stub, 
		quando l'utente si iscrive non invia lo stub in modo da poter serializzare gli utenti registrati,
		nell interfaccia remota dell'oggetto esportato dal server invece ho implementato un metodo
		che il client puo usare per inviare al server lo stub quando si logga al server, in questo modo 
		gli utenti vengono comunque serializzati on demand senza lo stub, quando si loggano 
		ogni utente avra il suo stub lato server in modo da poter ricevere notifiche, quando effettueranno il
		logout lo stub verra tolto.
		A questo punto, sembra funzionare tutto correttamente, e posso cominciare a implementare appunto
		la fase di login tramite connessione TCP:
			
		Parto dall implementazione lato server: 
		NOTA IMPORTANTE: Devo ricordarmi che le info come IP e PORT devono essere prese dal file di config
		,il pars di tali iinfo devo ancora implementarlo NON DEVO DIMENTICARLO, per ora le uso temporane, 
		Ora devo vedere come effettuare il parse dei messaggi che il client invia al server, devo capire se
		all interno dello StartServer devo leggere l operazione che bisogna essere fatta e poi lanciare 
		un thread del pool che usa un task specifico per quella operazione, oppure fare un unico task che 
		riceve l input e in base all input ricevuto fa diverse operazioni, in quest ultimo modo forse sono
		meno ordinato ma piu veloce, nel primo modo forse ottengo un codice piu leggibile per iul thread
		che accetta le connessioni deve comunque effettuare delle operazioni di parsing => perde un po di 
		tempo, quindi io credo che l operazione migliore da fare sia lanciare un tipo di task unico con 
		al suo interno diversi metodi privati che effettuano le diverse operazioni ma cosi facendo il 
		server che fa il multiplexing è piu efficente.
		Riguardo l'implementazione della classe che effettuerà veramente le operazioni, la prima 
		cosa che devo valutare sono gli oggetti che devo passare nel costruttore in base alle operazioni che il 
		thread deve fare; Innanzi tutto al task bisogna passare la SelectioKey per recuperare il channel
		e fare le diverse operazioni di comunicazione, devo vedere anche il resto.
		Prima cosa che implemento è la fase di login, quindi quella che registra i client al servizio di 
		ricezione della notiica, ora devo pensare a come tenere traccia degli utenti loggati, 
		inserisco un campo nella classe utente che aggiorno in seguito a login e logout, oppure
		uso un altra struttura dati? Credo che la prima opzione sia la migliore.
		Altri parametri che credo siano necessari sono le lock e le condition variable.
		Sono arrivato alla fase in cui devo cominciare a leggere i dati che ricevo, a questo punto, 
		è necessario utilizzare un protocollo di comunicazione standard, nelle specifiche non 
		viene detto nulla sul tipo di protocollo usare, quindi in teroia devo crearlo io.
		
		
		PROTOCOLLO COMUNICAZIONE::::: 
			1) Ogni messaggio conterrà all inizio del messaggio la lunghezza del messaggio stesso
			cosi all inizio leggo 4 byte cioe un int che indichera la dim, dopo di che inizio a leggere il 
			messaggio
		 
		 

-------------------------------------------------------------------------------------------------------------------

Giorno 8):

		Ricomincio da dove sono arrivato al giorno 7:
		Per ora voglio implementare il login, quindi devo connettermi al server e inviare :
		"login(username, password)", nel mio protocollo il rimo dato che scriov è la dim dell
		intero messaggio, come secondo campo il nome dell'operazione, e poi successivamente 
		i parametri dell operazione, i vari campi saranno separati da un singolo spazio, mentre
		il nome della operazione dai campi sara separata dai ':' ad esempio
		riguardo il login, la richiesta sara ad esempio
		
		23login:username password
		
		Per quanto riguarda l attach che aggancio alle key, per ora posso considerare di usare solo
		una stringa, dopo magari meglio usare una classe mia per creare i dati da inviare e poi costruire 
		una stringa da inviare al client.
		
		Riguarrdo il formato del messaggio di risposta, sara come la richiesta, in cui all'inizio sarà 
		inserita la dimensione del messaggio, poi dopo il nome del "metodo" che ha fatto la richiesta 
		e poi i parametri della risposta, fra questi pero nella risposata verra inserito un parametro 
		che indica il successo della richiesta oppure il fallimento, userò una "enumeraziopne" di ack
		per far capire al client il motivo del fallimento.
		
		Note: 1)I blocchi try catch che contengono nella catch una Exception generica dovranno poi essere sistemati 
		per bene
		      2)Riguardo la lettura dei dati che il client invia mi trovo davanti a due scelte, o far si
		      che il thread legga tutti i dati che il client invia per costruire la risposta, oppure 
		      comlicandomi un po la vita, quello che posso fare è:
		      	1) Creare un mio attachment in cui inserisco un campo per indicare se all interno i dati sono pronti per
		      	essere inviati e per indicare al thread se i dati dal channel sono stati letti tutti o meno e inoltre
		      	inserire ad esempio un asterisco alla fine di ogni messaggio che il server riceve per indicare la
		      	file del messaggio (anche se comunque puo essere visto con il numero di byte letti).
		      	Io dico di provare a fare la soluzione non bloccante per farlo inizio implementando il mio attached
		      	in cui inserisco un campo per indicare che i dati presenti sono completi, un campo per indicare 
		      	l'inizio della lettura dei dati,  e poi i vari campi per i dati, siccome la stessa richiesta
		      	puo essere diciamo "completata" in tempi diversi, è necessario che all'interno dell attached vengano
		      	inserite strutture dati per memorizzare tutto quello che si è letto dalchannel in un determinato 
		      	momento => devo usare degli array per questo e anche fino a dove sono arrivato a scrivere in questo
		      	array. 
		      	
		      	Nota importante: Devo usare una lock per accedere all utente quando serializzo, tale lock deve essere 
		      	condivisa fra il thread che accedono ai registrati.
		      	

-------------------------------------------------------------------------------------------------------------------

Giornio 9):	

		Ho bisogno di gestire il fatto che un client anche se si logga potrebbe disconnettersi in un qualsiasi momento, 
		ho visto che quando succede mi espode il server perche per come è adesso vengono lanciati infinitamente i thread 
		che eseguono work ed esplode tutto, come farre??????: devo controllare sia in fase di scrittura che di lettura cosa mi ritornano
		la read e la write e muovermi di conseguenza.
			Note riguardo la registrazione sul selettore:
				Dentro Attached è presente un campo complited che mi permette poi all'interno del thread
                     		* che fa lo smistamento delle connessioni di poter vedere se i dati sono stati inviati tutti oppure no,
                     		* nel casoo in cui i dati che il thread che smista le conn invia siano tutti il channel viene registrato
                     		* per la readable, altrimenti no.
                     		
               Nota: siccome la funzione di parsing delle richieste mi serve in piu punti, creo una classe con metodi statici in modo da poter
               utilizzare i suoi metodi dove mi pare (MyMethodClass.java), per ora è solo una finezza pero quindi lascio stare.
               
               Nota: riguaro il metodo di logout, siccome tale metodo richiede di inserire il nome dell utente che deve effettuare
               il logout, quello che potrebbe succede è che un utente inserisca il nome di un altro utente, allora quello che devo fare
               è inserire all interno della classe utente una variabgile di instanza che al momento di login associ a quell utente
               la sua connessione, la sua key oppure il suo attach oppure il suo channel, in modo che se il client chiede di effettuare il
               logout se non inserisce il nuo nome e quindi indicare che deve effettuare il logout l utente associato alla conn
               che ha effettuato la richiesta => venga sollevato un errore.
               
               Ritornando al login invece, va implementato, ricordandosi che quando un client si logga si iscrive al servizio di notifiche
               quindi anche lato client devo cominciare a scrivere bene
                    
		
		Nota: per i thread secondari, per farlio terminare potrei settarli come demoni in modo tale che una volta terminati tutti i
		thread non demoni il programma si chiude lo stesso.
			
		Nota: In work -1 indica ch l'username non è fra i registrati, 0 indica login con successo (usero 0 anche per le altre operazioni)
		0 operazione completata numeri negativi operazione fallita e per ogni numero negativo un significato 

-------------------------------------------------------------------------------------------------------------------

Giorno 10): ho riosolto un po di problemi pero ora non capisco perche non mi entra nel ramo iswriteable, da fixare:

Giorno 10.1) :
		
		
		provo a fixare il problema dell iswriteable: per farlo posso provare a registrare il canale sul selettore come writable nel 
		thread che gestisce le conn non dai thread, e uso un campo in attach per vedere se i dati dentro attach sono 
		pronti o no, inoltre l attach è condiviso fra thread, quindi devo accedervi in mutua esclusione => uso le lock
		ma uso la trylock per non far si che il gestore dei channel debba aspettare i thread worker 

		devo implementare correttamente la muta esclusione sulle selectedkeys, per farlo mi serve una struttura dati
		in cui inserisco la chiave presa dall iteratore e anche una lock, cosi posso accedere alla chiave in modo esclusivo
		sia dal thread che regola i channel sia dai worker senza rallentare tutto e il resto lasciarlo cosi, questo perche altrimentu
		mi da problemi il selettore
		Non ho idea di come fare, pero posso usare un altra strateggia, 
		Faccio in modo che la classe work implementi callable in modo da poter recuperare i dati dopo che li ha prodotti 
		
		con un oggetto feature, in piu associo ad ogni chiave un id, per identificare la connessione e ad ogni thread che sta
		elaborando i dati, associo tale id, in questo modo pero per ogni richiestail thread deve completarla tutta.
		Dopo che il thread ha finito quindi recupero il dato e se la connessione è pronta per la scrittura e se l id della 
		connessione coincide con l id dell dato prodotto dai thread in questo modo i thread leggono dal canale e basta e 
		producono il dato => non dovrei avere problemi con il selettore                                  
		

-------------------------------------------------------------------------------------------------------------------

Giorno 11) : Il meccanismo che volevo implementare non mi piace, ora faccio in modo che se un channel è legibile => leggo tutti i dati
	     e preparo direttamente la risposta da un solo thread, altrimenti diventa ingestibile e non ha nemmeno molto senso.
	    In pratica quello che devo fare è: quando la connessione è pronta per la lettura, faccio una prima operazione di lettura nel
	    thread che gestisce le connessioni cercando di leggere la dimensione, se non ritorna -1 allora passo quella dimensione ai worker e 
	    gli faccio farre il resto, altrimenti elimino la connessione dal selettore. 
	    
	    Per ora dovrebbe andare, ho sistemato la chiusura della connessione lato client, ho fatto in modo di non far bloccare 
	    il selettore, ho pero dovuto far si che i worker debbano servire ognuno una richiesta alla volta pero ho 
	    eliminato le lock quindi bene o male a bene, ora c'è da gestire il fatto che se si prova a loggare un utente 
	    che non è registrato c'è il motodo del server che tenta di prendere dal client lo stub ma viene sollevata un eccezzione
	    questo si puo gestire facilmente. 
	    Per ora mi fermoi qua che devo fdare IA poi continuo....
	    
	    

-------------------------------------------------------------------------------------------------------------------

Giorno 12) Sistemo solo alcune cose semplici (Rifiniture), 
		Nota: quando dovro mandare una notifica ad un client per un qualsiasi motivi, dovro controllare lato server 
		che il client sia loggato prima di cercare lo stuib del cliente e inviare la notifica 

-------------------------------------------------------------------------------------------------------------------

Giorno 13)	Ricomincio :
		Sto riflrttendo sulla serializzazione, la serializzazione dell utente, quando deve essere fatta??
		Perche ogni qiual volta che la struttura dati degli utenti viene modificata, biosogna mantenere nel file
		json i dati in modo consistente, quindi a questo punto devo decidere bene quando tale serializzazione debba
		essere fatta, io credo che il modo migliore sia quando un utente fa il logout oppure periodicamnete
		inoltre gestire i dati del file json è abbastanza dura, anche perche è difficile modificare
		un singolo utente all interno del json, quindi quello che mi conviene fare e ricostruire periodicamente
		il file json, fare un backup periodico, è impraticabile farlo di continuo, in questo modo evito di rallentare il gioco
		per la sincronizzazione ma farlo solo periodicamente, inoltre forse conviene usare due strutture dati per gli utenti, 
		in base a cosa devo fare, ad esempio, se devo registrare un utente non ci sarebbe bisogno di rallentare 
		chi sta giocando, quindi per fare questo o uso due strutture dati, oppure provo a usare la concurrenthashmap 
		in modo da poter accedere in mutua esclusione ai singoli buckets della struttra per questa cosa va prima studiata e capita
		bene, se uso una concurrentHashmap quello che devo fare è: inizializzare la mappa con un numero di capacita iniziale
		un workload standard.
		Altra considerazione da fare, riguardo la struttura dati che viene condivisa fra thread, tale struttura dati puo avere
		 problemi di
		 concorrenza quando?? il punto è che nella funzione dei worker, io non accedo mai da piu thread allo stesso utente, in
		caso succedesse ad esempio per il login, non avrei comunque problemi se 2 utenti provano a logagrsi con 2 
		passwd diverse, non centra con la concorrenza, inoltre, riguardo la logout, per evitare che un utente possa inserire
		l username di un altro utente e fargli fare la logout, va inserito un campo nella classe utente per specificare
		su quale ID_CHANNEL l utente si è loggato, cosi faccio questo controllo nella logout e risolvo il problema cosi puo
		effettuare la logout solo un utente che è loggato e che ha effettuato il login con la stessa socket che usa per fare 
		la logout.
		Per oggi non ho scritto nulla sul codice, ho fatto solo queste considerazioni, da domani mi ci metto.........	
		
		
-------------------------------------------------------------------------------------------------------------------


Giorno 14)	Voglio provare a usare la concurrenthashmap, in questo modo DEVO eliminare RWlck dove la uso, comincio dalla 
		Implementazione registrati
		1)Modifico la struttura dati registrati, per ora lascio i parametri di default con livello di concorrenza == 16
			visto che io uso una macchina di 8 gb di ram => 16 thread massimi, poi in base alla macchina che si usa 
			si puo incrementare questo paramentro creando una struttura dati con tale parametro, usero il file
			di config per farlo e va scritto nella relazione.
			Per ora la lascio senza nulla perche voglio vedere prima se funziona
			
		2) Modifico il makejson, 
		Sembra che la concurrenthashmap funzioni, ora comincio a implementare il logout
		
		Logout: Nota: per ora è solo rudimentale, pero poi faro in modo che il logout come opzione venga visualizzata 
		solo dopo aver effettuato il login e quindi aver stabilito la conn con il server, 
		Nota: ho un problema riguardo la chiusura della connessione lato server, cioe quando bisogna chiudere la
		connessione della socket lato server, credo che il thread cche gestisce i channel debba chiudere la 
		connessione con il client
		Nota: ho dimenticato di considerare il fatto che un utente possa provarre a effettuare la ligin anche dopo essere gia stato 
		loggato, va implementato anche questo controllo
		Sembra che il problema che mi stavo ponendo non c'è, da capire bene come funziona la cancel della key, il fatto è che ora 
		non va piu nel ramo readable perche lato client nn chiudo la connessioneeee okok ho capitooooo.
		Ora pero rimane il fatto che faccioattesa attiva per la scrittura, questa cosa potrebbe essere migliorata facendo in modo 
		che siano i worker a scrivere la risposta al client direttamente...
		Riguardo la logout invece va bene sembra funzionareeeeeee daje roma dajeee    		

-------------------------------------------------------------------------------------------------------------------

Giorno 15)	Ricomincio da dove ero arrivato ieri: 
		Adesso stavo pensando al fatto che dopo aver letto, finche i worker non hanno finito di elaborare la risposta, il thread
		che gestisce le conn va in loop, non si ferma sulla select perche il channel è pronto per la scrittura ma i worker
		ancora non hanno preparato la risposta corretta.
		
		******************************IMPORTANTEEEEE********************************
		
		Ricordando che va sistemata la serializzazione devo serializzare periodicamente non solo alla fase di registrazione
		
		******************************IMPORTANTEEEEE********************************
		
		Ora comincio a implementare le robe per il gioco vero e proprio, comincio dalle strutture dati lato server
		Per prima cosa il gioco prende la parola da un vocabolario fornito, tale vocabolario va letto da e caricato in memoria, 
		comincio quindi dalla fase di lettura del bocabolario, prima pero devo capire come questo vocabolario debba essere usato
		In quaole struttura dati memorizzo le parole??? credo in una hashmap in modo da poter accedere al valore
		in tempo 0, inoltre devo sistemare la roba riguardo i dati di config come la porta ecc
		
		
-------------------------------------------------------------------------------------------------------------------

Giorno 16)	Oggi provo a implementare la GUI e di conseguenza a sistemare il client in modo da poter testare il programma per bene 
		anche da terminale perche per ora da terminale non funziona bene e mi serve che funzioni perche devo testare con piu client
		
		Per ora ho capito come creare una GUI, adesso divido il client in due parti:
		Userò un campo che viene passato da riga di comando per selezionare la modalita con cui far partire il client,
		in modo da poter testare correttamente il programma per i miei test.
		Ora provo a implementare correttamente la gui per come deve essere:
		Ho implementato il frame per effettuare login e registrazione, ora devo trasferire la parte di back-end :
			NOTA: Ancora lato client non ho implementato la fase di configurazione leggendo dal file, per
			ora vado avanti, poi dovro fare in modo che il client legga le info e le trasferisca al modulo della gui
			corretto



-------------------------------------------------------------------------------------------------------------------


Giorno 17) 	Riguardo la prima interfaccia che si apre all avvio del programma, potrei inserire una descrizione del gioco nello spazio
		vuoto che c'è sotto le opzioni di login e registrazione ma è una cosa che farò dopo magari, ora mi concentro sull andare 
		avanti:
		Lato server devo ricordarmi di togliere lo stub e di modificare il fla di login, quando il client effettua il logout oppure 		chiude la connessione per qualsiasi altro motivo, per farlo il thread che gestisce le connessioni dovrebbe sapere il nome 
		del client che ha chiuso la connessione, tale thread non è in possesso di tale info ma posso farla inserire ai
		worker quando effettuano l'operazione di login nella struttura dati di tipo future, Sembra funzionare,
		Continuo lato client con l operazione di logout ecc
		
		Nota: Attenzione alle specifiche del progetto, controllare le stringhe vuote
		
		Ora dopo  aver implementato acnhe la fase di logout, comincio lato server a implementare le strutture dati per iniziare a 
		giocare, per ora implemento nel client in modo barbaro con interfaccia a caratteri per testare, poi implemento 
		l'interfaccia grafica.
		
		Comincio lato server a ragionare riguardo al gioco: Bisogna implementare una struttura dati che mantiene la 
		parola del giorno, ogni utente prima di partecipare al gioco è necessario che usi il metodo playWORDLE() dopo
		aver effettuato il login, scrivo un po di opzioni:
		1) Implementare un unica struttura dati non contenuta ad esempio all interno degli utenti registrati, bisogna
		pero trovare il modo di mantenere in tale struttura le info riguardo gli utenti che partecipano al gioco ecc
		Si puo fare in modo che ogni tot di tempo (quello indicato nel file di configurazione) vanga creato un oggetto di 
		tipo gioco e che venga mantenuto in memoria (in caso di chiusura del server deve anche essere serializzato)
		La struttura datio gioco deve mantenere oltre alle ovvie info tipo parola e metodi per poter lavorare con la parola:
		
			1) Chi ha iniziato a partecipare al gioco e i tentativi effettuati, devo capire come memorizzare tali info
			   e gestirle in modo concorrente, motrei usare un altra concurrenthashmap in modo da non dover sincronizzare tutta la
			   struttura dati, oppure potrei usare una blockingqueue di coppie <String (Username), Integer (tentativi)>
			   Devo inoltre capire bene anche come implementare il vocabolario, se usare un arraylist o un hashmap, usare
			   un arraylist sarebbe potenziaolmente molto costoso, anche se comunque il numero di parole è costante, 
			   potrei usare un hashmap ma potrei occupare troppo con tutta queste hashmap, penso che usero un arraylist di stringhe
			   
			   Devo capire pero come faccio a far si che ogni tot di tempo venga generata una nuova parola, dovrei in teoria
			   dedicare un thread a fare questa operazione, per farlo pero  devo capire come faccio a fargli capire che
			   il timer è scaduto e quindi svegliarsi, perche il server potrebbe anche spegnersi e in tal caso
			   come faccio a sapere quanto tempo è passato dall ultima parola estratta??
			   Quello che mi viene in mente è che potrei usare il file di configurazione o il file json,
			   cioe, ad ogni chiusura del server salvare sul file la data è l ora del ultima parola generata, in questo
			   modo al nuovo avvio posso recuperare tale info e fare la differenza fra il tempo attuale e quello 
			   di questa info, riguardo invece la generazione della parola in run, ad esempio se il server non è spento 
			   e passa il tempo per generare la nuova parola, come posso fare?? Dovrei lanciare un thread che esegue 
			   una sleep lunga tanto quanto il tempo nel file di config e poi generare la nuova parola quindi il nuovo gioco
			   posso fare in modo che sia un thread demone efinezze del genere, pero cosi comunque ho un thread in piu da 
			   far lavorare e quindi ulteriori context switch, domani comincio, 
			   
			   NOTA: devo fare il file di config anche per il client e aggiungere al server la porta d ausare con la socket 
			         

-------------------------------------------------------------------------------------------------------------------

Giorno 18)	Riprendo da dove ero arrivato ieri:  Comincio con l' implementazione del gioco	
		Nota: La serializzazione di SessioneWordle dati deve essere effettuata come ultima operazione in modo da 
		poter poi recuperare dal file json l'oggetto. 
		Utilizzo un'altra concurrenthashmap per poter gestire la concorrenza, tale concurrenthashmap sazlverà gli username
		degli utenti che hanno cominciato a giocare come key e userà come valore :
			Per ora il numero di tentativi effettuati di indovinare la parola, pero potrei usar eanche una struttura dati
			apposita in caso dovessero servire altre info, NOTA: per quanto riguarda le operazioni che richiedono gli
			eventuali client, per ogni operazione, oltre alle info che sono richieste dai metodi della specifica 
			dovranno anche inviare (senza che l'utente debba inserire nulla) anche l username perche al server
			serve tale info per accedere alle strutture dati, questo è possobile farlo perhce gli utenti quando devono
			giocare devono fare il login, quindi hanno necessita di scrivere il loro username che mantengo in mem e che usero 
			per fare questo:
			Riguardo il metodo playWORDLE il client non inserisce nessuna info ma come ho detto il client invia l username
			
			PROBLEMAAAAAAAAAA: come faccio a far si che ci sia sempre un thread in background che crea un oggetto di
			tipo gioco e tale oggetto possa essere usato in altre classi senza essere ritornato dal metodo run??
			Il metodo run non puo ritornare perche deve stare in attesa di poter creare allo scadere del timer il nuovo
			gioco, quibdi come devo fare???????
			Soluzione: Implementare il metodo run e metodo get per far ritornare l oggetto
			
			Nota : i thread che non sono da lavoro posso lanciarli normalmente con un oggetto thread e non con il threadpool
			perche quest ultimo ha un numero di thread limitato, questa cosa la devo cambiare
			
			All interno del file di config inserisco il campo lasttimewordle che indica l ultima volta in cui
			è stata lanciata la parola del gioco 
			Nota: per ora il timestamp che indica ogni quanto la parola deve essere prodotta conta giorni e ore,
			posso inserire anche i minuti per rendere piu precisa l operazione:
			
			       
				

-------------------------------------------------------------------------------------------------------------------
Giorno 19)
		Per fare la roba con html mi sembra troppo esagerato e mi prende un po troppo tempo, per ora provo cosi e vedo come va
		nel caso ci ripenso in un secondo momento, 
		Riprendo da dove ero arrivato ieri:
		
		Nota: la parola deve essere spawnata ogni volta che scade il eimestamp messo nel paramentro di config
		
		NOTA IMPORTANTISSIMA:::: RIguardo sessionewordle, la word e la concurrenthashmap tentativi sono protetti dalla
		readwritelock in scrittura perche c'è il thread che periodicamente aggiorna la sessione, riguardo i singoli thread che 
		accedono ai packets della concurrenthashmap invece essendo una concurrenthashmap non ho bisogno di usare lock, in questo modo
		siccome nei worker uso la readlock non ho problemi quando sono i worker ad entare in concorrenza, perche tutti
		possono leggere dalla sessione senza bloccarsi e poi ci pensa la concurrenthashmap a fare la mutua esclusione
		sui backets
		
-------------------------------------------------------------------------------------------------------------------


